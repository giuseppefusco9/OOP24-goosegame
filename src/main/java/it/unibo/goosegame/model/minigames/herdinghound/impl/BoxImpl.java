package it.unibo.goosegame.model.minigames.herdinghound.impl;

import it.unibo.goosegame.model.minigames.herdinghound.api.Box;
import it.unibo.goosegame.model.minigames.herdinghound.api.Dog;
import it.unibo.goosegame.utilities.Position;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

/**
 * Implementation of the Box interface for the Herding Hound minigame.
 * Manages the position and generation of boxes and their shadows.
 */
public final class BoxImpl implements Box {

    private static final double BOX_PROBABILITY = 0.6;
    private static final int BORDER_MARGIN_DIVISOR = 2;
    private static final int SHADOW_WIDTH_MIN_DIVISOR = 10;
    private static final int SHADOW_MAX_LENGTH = 1000;

    private final Set<Position> allBoxes = new HashSet<>();
    private final Set<Position> shadows = new HashSet<>();
    private final int gridSize;
    private final int boxDistance;
    private final Random random;
    private final Position pointLux;

    /**
     * Constructs a BoxImpl object.
     * @param gridSize the size of the grid
     * @param dog the dog instance
     */
    public BoxImpl(final int gridSize, final Dog dog) {
        this.gridSize = gridSize;
        this.boxDistance = BORDER_MARGIN_DIVISOR;
        this.random = new Random();
        this.pointLux = new Position(dog.getCoord().x(), dog.getCoord().y());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Position> getBoxes() {
        return new ArrayList<>(allBoxes);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateBoxes() {
        this.allBoxes.clear();
        this.shadows.clear();

        // Block all cells above the upper box line (x < boxDistance)
        for (int x = 0; x < this.boxDistance; x++) {
            for (int y = this.boxDistance; y < this.gridSize - this.boxDistance; y++) {
                // Skip start and end positions
                if (!(x == 0 && y == this.boxDistance || x == 0 && y == this.gridSize - this.boxDistance - 1)) {
                    this.allBoxes.add(new Position(x, y));
                }
            }
        }

        for (int y = this.boxDistance; y < this.gridSize - this.boxDistance; y++) {
            tryAddBox(new Position(this.boxDistance, y));
        }

        for (int x = this.boxDistance + 1; x < this.gridSize - this.boxDistance; x++) {
            tryAddBox(new Position(x, this.gridSize - this.boxDistance - 1));
        }

        for (int y = this.gridSize - this.boxDistance - 1; y >= this.boxDistance; y--) {
            tryAddBox(new Position(this.gridSize - this.boxDistance - 1, y));
        }

        for (int x = this.boxDistance + 1; x < this.gridSize - this.boxDistance; x++) {
            tryAddBox(new Position(x, this.boxDistance));
        }
    }

    private void tryAddBox(final Position box) {
        if (this.random.nextDouble() < BOX_PROBABILITY) {
            this.allBoxes.add(box);
            generateShadows(box);
        }
    }

    private void generateShadows(final Position box) {
        final int lightX = this.pointLux.x();
        final int lightY = this.pointLux.y();
        final int dx = box.x() - lightX;
        final int dy = box.y() - lightY;
        final int stepX = Integer.compare(dx, 0);
        final int stepY = Integer.compare(dy, 0);

        // Avoid infinite loop: if the box coincides with the light, no shadow.
        if (stepX == 0 && stepY == 0) {
            return;
        }

        final double distance = Math.sqrt(dx * dx + dy * dy);
        final int shadowWidth = (int) Math.max((double) gridSize / SHADOW_WIDTH_MIN_DIVISOR, gridSize / distance);
        int shadowLength = Math.min(gridSize, SHADOW_MAX_LENGTH);

        int shadowX = box.x() + stepX;
        int shadowY = box.y() + stepY;

        while (this.isInBounds(shadowX, shadowY) && shadowLength > 0) {
            for (int i = -shadowWidth; i <= shadowWidth; i++) {
                final int newShadowX = shadowX + i * stepY;
                final int newShadowY = shadowY + i * stepX;

                if (this.isInBounds(newShadowX, newShadowY)) {
                    this.shadows.add(new Position(newShadowX, newShadowY));
                }
            }
            shadowX += stepX;
            shadowY += stepY;
            shadowLength--;
        }
    }

    private boolean isInBounds(final int x, final int y) {
        final boolean isOnBorder = x <= this.boxDistance || x >= this.gridSize - this.boxDistance - 1
            || y <= this.boxDistance || y >= this.gridSize - this.boxDistance - 1;
        return isOnBorder
            && x >= 0 && x < this.gridSize
            && y >= 0 && y < this.gridSize;
    }

    /**
     * Returns the list of shadow positions generated by the boxes.
     * @return list of shadow positions
     */
    @Override
    public List<Position> getShadows() {
        return new ArrayList<>(this.shadows);
    }
}
